* Map use cases before going too far with the implementation
* Cover edge cases
* Find or make a kd-tree implementation that preserves order
* Assert that n1>n2 in Match._extract_groups--for now 
* Matching algorithms should check for null values
* Matching algorithms should check for mismatched lengths
* Matching algorithms should be able to enfore common support
* Matching algorithms should accept caliper
* Consider adding replacement/no-replacement to matching algorithms
* Match.match should raise error if invalid algorithm is given
* Enforce procedureal order: Must fit, before match, before results
* Implement mahalanobis matching
* Separate out a matching class from MahalanobisMatching and PropensityScoreMatching
* Check that class names reflect the domain names and remove possible naming conflicts
* Create test cases for probit
* Add support/polymorphism for numpy and pandas types - -try to use numpy internally
